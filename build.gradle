buildscript {
    repositories {
        mavenCentral()
    }

    dependencies {
        classpath("com.google.guava:guava:31.0.1-jre")
        classpath("commons-io:commons-io:2.11.0")
    }
}


import com.modrinth.minotaur.TaskModrinthUpload
import com.modrinth.minotaur.request.VersionType
import groovy.json.JsonOutput
import groovy.json.JsonSlurper

plugins {
    alias(libs.plugins.curse)
    alias(libs.plugins.modrinth)
    alias(libs.plugins.names)
}

allprojects {
    apply plugin: "java"

    java.toolchain.languageVersion = JavaLanguageVersion.of(17)

    tasks.withType(JavaCompile) {
        options.encoding = "UTF-8"
        options.compilerArgs = ["-Xlint:deprecation"]
    }

    dependencies {
        compileOnly(libs.jetbrainsAnnotations)
        compileOnly(libs.lombok)
        annotationProcessor(libs.lombok)
    }

    repositories {
        mavenCentral()
        maven {
            name = "Minecraft Libraries"
            url = uri("https://libraries.minecraft.net")
        }
        maven {
            name = 'CurseForge'
            url = 'https://minecraft.curseforge.com/api/maven'
        }
        maven {
            name = "ModMenu"
            url = "https://maven.terraformersmc.com/releases/"
        }
        maven {
            name = "Cloth Config"
            url = "https://maven.shedaniel.me/"
        }
    }
}

var minecraftVersion = libs.versions.minecraftVersion.get()
group = "fr.raksrinana"
archivesBaseName = "${project.modName}-${minecraftVersion}"

task buildJar(type: Jar, group: "modding") {
    dependsOn(assemble)
    dependsOn(":common:build")
    if (project.includeFabric.toBoolean()) {
        dependsOn(":fabric:build")
    }
    if (project.includeForge.toBoolean()) {
        dependsOn(":forge:build")
    }

    if (project.includeForge.toBoolean()) {
        finalizedBy(":forge:signJar")
    }

    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    from {
        zipTree("common/build/libs/common-${project.version}.jar")
    }
    if (project.includeFabric.toBoolean()) {
        from {
            zipTree("fabric/build/libs/fabric-${project.version}.jar")
        }
    }
    if (project.includeForge.toBoolean()) {
        from {
            zipTree("forge/build/libs/forge-${project.version}.jar")
        }
    }

    manifest {
        attributes([
                "Specification-Title"     : project.modId,
                "Specification-Vendor"    : "RakSrinaNa",
                "Specification-Version"   : project.version,
                "Implementation-Title"    : project.modName,
                "Implementation-Version"  : "${project.version}",
                "Implementation-Vendor"   : "RakSrinaNa",
                "Implementation-Timestamp": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
        ])
    }
}
assemble.finalizedBy("buildJar")

curseforge {
    afterEvaluate {
        tasks["curseforge${project.curseforge_project_id}"].dependsOn("buildJar")
    }

    def relType = "release"
    if (version.contains("b")) {
        relType = "beta"
    }
    if (version.contains("a") || version.contains("dev")) {
        relType = "alpha"
    }

    apiKey = "${project.findProperty("curseforgeApiKey")}"
    project {
        id = "${project.curseforge_project_id}"
        changelogType = "markdown"
        addGameVersion(minecraftVersion)
        addGameVersion("Java 17")
        if (project.includeFabric.toBoolean()) {
            addGameVersion("Fabric")
        }
        if (project.includeForge.toBoolean()) {
            addGameVersion("Forge")
        }
        changelog = project.findProperty("changelog") ?: "No changelog provided"
        releaseType = relType
        mainArtifact(jar) {
            displayName = "${minecraftVersion}-${project.version}"
        }
        relations {
            if (project.includeFabric.toBoolean()) {
                optionalDependency("fabric-api") //It's actually required
                optionalDependency("modmenu")
                optionalDependency("cloth-config")
            }

            if (project.includeForge.toBoolean()) {
                optionalDependency("cloth-config-forge")
            }
        }
    }
    options {
        javaVersionAutoDetect = false
        javaIntegration = false
        forgeGradleIntegration = false
    }
}

task publishModrinth(type: TaskModrinthUpload, group: "upload") {
    dependsOn buildJar
    def relType = VersionType.RELEASE
    if (version.contains("b")) {
        relType = VersionType.BETA
    }
    if (version.contains("a") || version.contains("dev")) {
        relType = VersionType.ALPHA
    }

    token = project.findProperty("modrinthToken") as String
    projectId = project.modrinth_project_id
    versionNumber = "${minecraftVersion}-${project.version}"
    versionName = "${minecraftVersion}-${project.version}"
    uploadFile = jar
    addGameVersion(minecraftVersion)
    if (project.includeFabric.toBoolean()) {
        addLoader("fabric")
    }
    if (project.includeForge.toBoolean()) {
        addLoader("forge")
    }
    versionType = relType
    changelog = project.findProperty("changelog") ?: "No changelog provided"
}

def writeUpdateJson(mcVersion) {
    def version = project.version as String
    def slurper = new JsonSlurper()
    def file = project.file("update.json")
    def json = slurper.parse(file)
    def changelogUrl = "https://github.com/${project.repoUser}/${project.repoName}/releases"

    if (!mcVersion.contains("w") && !version.contains("dev")) {
        json["changelog"] = changelogUrl

        // TODO: Maybe add something to create an abbreviated changelog? May not be useful...
        json.putIfAbsent(mcVersion, new HashMap<>())
        json[mcVersion].putIfAbsent(version, changelogUrl + "/" + version)
        json[mcVersion] = json[mcVersion].sort([compare: { a, b -> a.compareTo(b) }] as Comparator)
        json["promos"]["${mcVersion}-latest"] = version
        if (!version.contains("b") && !version.contains("a")) {
            json["promos"]["${mcVersion}-recommended"] = version
        }

        println(json)
        file.write(JsonOutput.prettyPrint(JsonOutput.toJson(json)))
    }
}

task createUpdateJson(group: "modding") {
    doLast {
        println("Updating update.json...")
        writeUpdateJson(minecraftVersion)
    }
}
build.finalizedBy createUpdateJson
